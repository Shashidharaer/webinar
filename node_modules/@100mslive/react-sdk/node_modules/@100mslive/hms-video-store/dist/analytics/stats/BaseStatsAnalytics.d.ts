import { LocalAudioTrackAnalytics, LocalBaseSample, LocalVideoSample, LocalVideoTrackAnalytics, PublishAnalyticPayload, RemoteAudioSample, RemoteAudioTrackAnalytics, RemoteVideoSample, RemoteVideoTrackAnalytics, SubscribeAnalyticPayload } from './interfaces';
import { EventBus } from '../../events/EventBus';
import { HMSTrackStats } from '../../interfaces';
import { HMSTrack } from '../../internal';
import { HMSWebrtcStats } from '../../rtc-stats';
import { Store } from '../../sdk/store';
export declare abstract class BaseStatsAnalytics {
    protected store: Store;
    protected eventBus: EventBus;
    protected readonly sampleWindowSize: number;
    protected readonly pushInterval: number;
    private shouldSendEvent;
    protected sequenceNum: number;
    protected abstract trackAnalytics: Map<string, RunningTrackAnalytics>;
    constructor(store: Store, eventBus: EventBus, sampleWindowSize: number, pushInterval: number);
    start(): void;
    stop: () => void;
    private startLoop;
    protected sendEvent(): void;
    protected abstract toAnalytics(): PublishAnalyticPayload | SubscribeAnalyticPayload;
    protected abstract handleStatsUpdate(hmsStats: HMSWebrtcStats): void;
}
declare type TempPublishStats = HMSTrackStats & {
    availableOutgoingBitrate?: number;
    calculatedJitterBufferDelay?: number;
    avSync?: number;
};
export declare abstract class RunningTrackAnalytics {
    readonly sampleWindowSize: number;
    track: HMSTrack;
    track_id: string;
    source: string;
    ssrc: string;
    kind: string;
    rid?: string;
    protected samples: (LocalBaseSample | LocalVideoSample | RemoteAudioSample | RemoteVideoSample)[];
    protected tempStats: TempPublishStats[];
    protected prevLatestStat?: TempPublishStats;
    constructor({ track, ssrc, rid, kind, sampleWindowSize, }: {
        track: HMSTrack;
        ssrc: string;
        kind: string;
        rid?: string;
        sampleWindowSize: number;
    });
    pushTempStat(stat: TempPublishStats): void;
    createSample(): void;
    clearSamples(): void;
    abstract shouldCreateSample: () => boolean;
    protected abstract collateSample: () => LocalBaseSample | LocalVideoSample | RemoteAudioSample | RemoteVideoSample;
    protected abstract toAnalytics: () => LocalAudioTrackAnalytics | LocalVideoTrackAnalytics | RemoteAudioTrackAnalytics | RemoteVideoTrackAnalytics;
    protected getLatestStat(): TempPublishStats;
    protected getFirstStat(): TempPublishStats;
    protected calculateSum(key: keyof TempPublishStats): number | undefined;
    protected calculateAverage(key: keyof TempPublishStats, round?: boolean): number | undefined;
    protected calculateDifferenceForSample(key: keyof TempPublishStats): number;
    protected calculateDifferenceAverage(key: keyof TempPublishStats, round?: boolean): number;
    protected calculateInstancesOfHigh(key: keyof TempPublishStats, threshold: number): number | undefined;
}
export declare const hasResolutionChanged: (newStat: TempPublishStats, prevStat: TempPublishStats) => boolean;
export declare const hasEnabledStateChanged: (newStat: TempPublishStats, prevStat: TempPublishStats) => boolean;
export declare const removeUndefinedFromObject: <T extends Record<string, any>>(data: T) => T;
export {};
