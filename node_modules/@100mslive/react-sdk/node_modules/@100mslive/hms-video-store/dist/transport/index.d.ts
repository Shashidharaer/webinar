import ITransportObserver from './ITransportObserver';
import { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';
import { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';
import { AnalyticsTimer } from '../analytics/AnalyticsTimer';
import { PluginUsageTracker } from '../common/PluginUsageTracker';
import HMSSubscribeConnection from '../connection/subscribe/subscribeConnection';
import { DeviceManager } from '../device-manager';
import { EventBus } from '../events/EventBus';
import { HMSRole } from '../interfaces';
import { HMSLocalTrack } from '../media/tracks';
import { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';
import { Store } from '../sdk/store';
import { InitConfig, InitFlags } from '../signal/init/models';
import JsonRpcSignal from '../signal/jsonrpc';
export default class HMSTransport {
    private observer;
    private deviceManager;
    private store;
    private eventBus;
    private analyticsEventsService;
    private analyticsTimer;
    private pluginUsageTracker;
    private state;
    private trackStates;
    private publishConnection;
    private subscribeConnection;
    private initConfig?;
    private endpoint;
    private joinParameters?;
    private retryScheduler;
    private webrtcInternals?;
    private publishStatsAnalytics?;
    private subscribeStatsAnalytics?;
    private maxSubscribeBitrate;
    joinRetryCount: number;
    constructor(observer: ITransportObserver, deviceManager: DeviceManager, store: Store, eventBus: EventBus, analyticsEventsService: AnalyticsEventsService, analyticsTimer: AnalyticsTimer, pluginUsageTracker: PluginUsageTracker);
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */
    private readonly callbacks;
    private signalObserver;
    readonly signal: JsonRpcSignal;
    private analyticsSignalTransport;
    private publishDtlsStateTimer;
    private lastPublishDtlsState;
    private publishConnectionObserver;
    private subscribeConnectionObserver;
    getWebrtcInternals(): HMSWebrtcInternals | undefined;
    isFlagEnabled(flag: InitFlags): boolean;
    preview(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    join(authToken: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, initEndpoint: string, autoSubscribeVideo?: boolean): Promise<void>;
    connect(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    leave(notifyServer: boolean): Promise<void>;
    handleLocalRoleUpdate: ({ oldRole, newRole }: {
        oldRole: HMSRole;
        newRole: HMSRole;
    }) => Promise<void>;
    publish(tracks: Array<HMSLocalTrack>): Promise<void>;
    unpublish(tracks: Array<HMSLocalTrack>): Promise<void>;
    /**
     * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
     * source. The hack won't work if there are multiple tracks with same source and type.
     */
    trackUpdate(track: HMSLocalTrack): void;
    private publishTrack;
    private unpublishTrack;
    private waitForLocalRoleAvailability;
    private createConnectionsAndNegotiateJoin;
    private createPeerConnections;
    private negotiateJoinWithRetry;
    private negotiateJoin;
    private negotiateJoinWebRTC;
    private negotiateJoinNonWebRTC;
    /**
     * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer
     */
    private negotiateOnFirstPublish;
    private performPublishRenegotiation;
    private handleIceConnectionFailure;
    private internalConnect;
    private validateNotDisconnected;
    private openSignal;
    private initRtcStatsMonitor;
    private initStatsAnalytics;
    private getValueFromInitConfig;
    /**
     * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything
     * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role
     */
    private doesRoleNeedWebRTC;
    private doesLocalPeerNeedWebRTC;
    private retryPublishIceFailedTask;
    private retrySubscribeIceFailedTask;
    private retrySignalDisconnectTask;
    private handleSubscribeConnectionConnected;
    private setTransportStateForConnect;
    private sendErrorAnalyticsEvent;
    getSubscribeConnection(): HMSSubscribeConnection | null;
    getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties;
}
